# 멀티 사이클 데이터패스 문제 풀이 (순차 실행)

## 명령어 목록

1. SW $t0, -100($t1) - Store Word (5 사이클: IF, ID, EX, MEM, WB)
2. LW $s0, 8($t1) - Load Word (5 사이클: IF, ID, EX, MEM, WB)
3. ADD $s2, $s1, $s1 - Add (4 사이클: IF, ID, EX, WB)
4. SUB $s5, $s4, $s3 - Subtract (4 사이클: IF, ID, EX, WB)
5. OR $t0, $t1, $t2 - Logical OR (4 사이클: IF, ID, EX, WB)
6. AND $t3, $t4, $t5 - Logical AND (4 사이클: IF, ID, EX, WB)

## 멀티 사이클 데이터패스 (순차 실행)

각 명령어가 완전히 끝난 후 다음 명령어가 시작됩니다.

| 명령어 | 사이클 범위 | 단계                                |
| ------ | ----------- | ----------------------------------- |
| SW     | 1-5         | IF(1), ID(2), EX(3), MEM(4), WB(5)  |
| LW     | 6-10        | IF(6), ID(7), EX(8), MEM(9), WB(10) |
| ADD    | 11-14       | IF(11), ID(12), EX(13), WB(14)      |
| SUB    | 15-18       | IF(15), ID(16), EX(17), WB(18)      |
| OR     | 19-22       | IF(19), ID(20), EX(21), WB(22)      |
| AND    | 23-26       | IF(23), ID(24), EX(25), WB(26)      |

## 7번째 클럭 사이클 분석

7번째 클럭 사이클에서:

- **LW $s0, 8($t1)**: ID 단계 (Instruction Decode) ← **이 단계가 제어 신호를 결정**

### LW $s0, 8($t1) 명령어의 ID 단계

LW는 I-type (Load Word) 명령어로:

- 형식: `LW rt, offset(rs)`
- 의미: `rt = Memory[rs + offset]`
- 이 경우: `$s0 = Memory[$t1 + 8]`

**ID 단계에서의 작업:**

- 명령어 디코딩
- 레지스터 파일에서 $t1 읽기
- Immediate 값(8) sign-extend
- 제어 신호 생성 (다음 EX 단계를 위해)

**참고:** 일부 구현에서는 ID 단계에서 제어 신호를 미리 설정하지만, 일반적으로 제어 신호는 해당 단계에서 사용됩니다.
7번째 사이클이 ID 단계이므로, 실제로는 다음 EX 단계(8번째 사이클)의 제어 신호를 준비하는 단계입니다.

하지만 문제에서 7번째 사이클의 제어 신호를 물었으므로, ID 단계에서 설정되는 제어 신호를 고려하거나,
또는 EX 단계의 제어 신호를 미리 설정하는 것으로 해석할 수 있습니다.

**일반적인 해석:** 7번째 사이클은 LW의 ID 단계이지만, 제어 신호는 보통 EX 단계에서 사용되므로,
EX 단계에서 필요한 제어 신호 값을 답으로 제시합니다.

## 제어 신호 값 (LW 명령어의 EX 단계 기준)

### (a) ALUSrcA

- **값: 0**
- 이유: LW는 I-type이지만 ALU의 첫 번째 입력은 항상 레지스터 파일의 A 출력(Read Data 1 = $t1)을 사용
- ALUSrcA = 0: 레지스터 파일의 A 출력 선택
- ALUSrcA = 1: PC 값 선택 (일부 특수한 경우)

### (b) ALUSrcB

- **값: 1**
- 이유: LW는 I-type 명령어이므로 ALU의 두 번째 입력은 sign-extended immediate 값(8)을 사용
- ALUSrcB = 0: 레지스터 파일의 B 출력 선택 (R-type용)
- ALUSrcB = 1: Sign-extended immediate 값 선택 (I-type용) ← **LW는 여기**

### (c) PCSource

- **값: 00** (또는 0)
- 이유: 일반적인 순차 실행 중이므로 PC+4를 사용
- PCSource = 00: PC+4 (순차 실행)
- PCSource = 01: Branch target (beq, bne 등)
- PCSource = 10: Jump target (j, jal 등)

## 정답

7번째 클럭 사이클에서 LW 명령어가 ID 단계에 있지만, 제어 신호는 EX 단계에서 사용되므로:

**(a) ALUSrcA = 0**
**(b) ALUSrcB = 1** ← LW는 immediate 값 사용
**(c) PCSource = 00** (또는 0)
